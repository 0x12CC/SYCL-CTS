:sectnums:
:xrefstyle: short

= Test plan for deduction guides

This is a test plan for deduction guides functionality of classes with templates, such as buffer, multi_ptr, range, id and vec.

== Testing scope

=== Device coverage

All of the tests described below are performed only on the default device that
is selected on the CTS command line if not stated otherwise.

=== Types coverage

`buffer` and `milti_ptr` are tested using types: `char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, float, std::size_t, user_struct, different_namespace::diff_namespace_struct, nested_struct::nested_user_struct`.

== Tests

=== `buffer`

Check that constructing an object without specifying template variables initializes object with correct `InputIterator`, `AllocatorT`, `range<Dimensions>` and `Container` classes.

* Create `buffer` using following constructors without templates using
** `InputIterator` from Types coverage
** `Allocator` - `sycl::buffer_allocator` and `std::allocator`
** `Container` template for `buffer` is `std::vector`
** `Dimensions` from 1 to 3

* `template <class InputIterator, class AllocatorT> +
buffer(InputIterator, InputIterator, AllocatorT, const property_list& = {}) -> buffer<typename std::iterator_traits<InputIterator>::value_type, 1, AllocatorT>;`

* `template <class InputIterator> +
buffer(InputIterator, InputIterator, const property_list& = {}) -> buffer<typename std::iterator_traits<InputIterator>::value_type, 1>;`

* `template <class T, int Dimensions, class AllocatorT> +
buffer(const T*, const range<Dimensions>&, AllocatorT, const property_list& = {}) -> buffer<T, Dimensions, AllocatorT>;`

* `template <class T, int Dimensions> +
buffer(const T*, const range<Dimensions>&, const property_list& = {}) -> buffer<T, Dimensions>;`

* `template <class Container, class AllocatorT> +
buffer(Container&, AllocatorT, const property_list& = {}) -> buffer<typename Container::value_type, 1, AllocatorT>;`

* `template <class Container> +
buffer(Container&, const property_list& = {}) -> buffer<typename Container::value_type, 1>;`

* Using `std::is_same_v` compare resulting object with deduction guide.
** Check that `value_type` is the same with `T`
** Check that `get_range()` returns same `range<Dimensions>`
** Check that `get_allocator()` returns same `AllocatorT`

=== `multi_ptr`

Check that constructing an object without specifying template variables initializes object with correct `T`, `access_mode`, `placeholder` and `Dimensions` classes.

* Create `accessor` and `local_accessor` using
** `T` from Types coverage
** `Dimensions` from 1 to 3
** `Mode` - `access::mode::read`, `access::mode::write`, `access::mode::read_write`

* Create `multi_ptr` using following constructors without specifying templates with existing `accessor`.

** `template <int Dimensions, access_mode Mode, access::placeholder IsPlaceholder,class T> +
multi_ptr(accessor<T, Dimensions, Mode, target::device, IsPlaceholder>) -> multi_ptr<T, access::address_space::global_space, access::decorated::no>;`

** `template <int Dimensions, access_mode Mode, access::placeholder IsPlaceholder, class T> +
multi_ptr(local_accessor<T, Dimensions>) -> multi_ptr<T, access::address_space::local_space, access::decorated::no>;`

* Using `std::is_same_v` Check that `get()` with * operator is same as `accessor::reference`.

=== `range` and `id`

Check that constructing an object without specifying `Dimensions` passes correct number of `size_t` arguments.

* Create `range` and `id` objects using following constructors
** `range(size_t) -> range<1>;`
** `range(size_t, size_t) -> range<2>;`
** `range(size_t, size_t, size_t) -> range<3>;`

** `id(size_t)->id<1>;`
** `id(size_t, size_t)->id<2>;`
** `id(size_t, size_t, size_t)->id<3>;`

* Using `std::is_same_v` compare type of resulting object and type with specified `Dimesions` template.

=== `vec`
* Create `vec` using constructor
** `template <class T, class... U> vec(T, U...) -> vec<T, sizeof...(U) + 1>;`

* Check sizeofthe `vec` using `size()`.

* Use `for` loop to check that elements inside vectors are the same with passed.
