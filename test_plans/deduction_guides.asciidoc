:sectnums:
:xrefstyle: short

= Test plan for deduction guides

This is a test plan for deduction guides functionality of classes with templates, such as buffer, multi_ptr, range, id and vec.

== Testing scope

=== Device coverage

All of the tests described below are performed only on the default device that
is selected on the CTS command line if not stated otherwise.

== Tests

=== `buffer`

Check that constructing an object without specifying template variables initializes correct `InputIterator`, `AllocatorT`, `Dimensions` and `Container` classes.

* Create `InputIterator`, `Allocator` and `Container`.

* Create `buffer` using following constructors without templates using existing `InputIterator`, `Allocator`, `Container` and from 0 to 3 `Dimensions`.

** `template <class InputIterator, class AllocatorT> +
buffer(InputIterator, InputIterator, AllocatorT, const property_list& = {}) -> buffer<typename std::iterator_traits<InputIterator>::value_type, 1, AllocatorT>;`

** `template <class InputIterator> +
buffer(InputIterator, InputIterator, const property_list& = {}) -> buffer<typename std::iterator_traits<InputIterator>::value_type, 1>;`

** `template <class T, int Dimensions, class AllocatorT> +
buffer(const T*, const range<Dimensions>&, AllocatorT, const property_list& = {}) -> buffer<T, Dimensions, AllocatorT>;`

** `template <class T, int Dimensions> +
buffer(const T*, const range<Dimensions>&, const property_list& = {}) -> buffer<T, Dimensions>;`

** `template <class Container, class AllocatorT> +
buffer(Container&, AllocatorT, const property_list& = {}) -> buffer<typename Container::value_type, 1, AllocatorT>;`

** `template <class Container> +
buffer(Container&, const property_list& = {}) -> buffer<typename Container::value_type, 1>;`

* Using `std::is_same_v` compare resulting object with deduction guide.
* Check that `get_range()` returns `range` with same `Dimensions` as in deduction guide.
* Check that `get_allocator()` returns same `AllocatorT` as in deduction guide.

=== `multi_ptr`

Check that constructing an object without specifying template variables initializes correct `T`. `access_mode`, `placeholder` and `Dimensions` classes.

* Create an `accessor`.

* Create `multi_ptr` using following constructors without templates .

** `template <int Dimensions, access_mode Mode, access::placeholder IsPlaceholder,class T> +
multi_ptr(accessor<T, Dimensions, Mode, target::device, IsPlaceholder>) -> multi_ptr<T, access::address_space::global_space, access::decorated::no>;`

** `template <int Dimensions, access_mode Mode, access::placeholder IsPlaceholder, class T> +
multi_ptr(local_accessor<T, Dimensions>) -> multi_ptr<T, access::address_space::local_space, access::decorated::no>;`

* Using `std::is_same_v` compare resulting object with deduction guide.
* Check that `get()` with * returns same value as `accessor` ref.

=== `range` and `id`

Check that constructing an object without specifying `Dimensions` passes correct number of `size_t` arguments.

* Create `range` and `id` objects using following constructors
** `range(size_t) -> range<1>;`
** `range(size_t, size_t) -> range<2>;`
** `range(size_t, size_t, size_t) -> range<3>;`

** `id(size_t)->id<1>;`
** `id(size_t, size_t)->id<2>;`
** `id(size_t, size_t, size_t)->id<3>;`

* Using `std::is_same_v` compare resulting object with deduction guide.

=== `vec`
* Create `vec` using constructor

** `template <class T, class... U> vec(T, U...) -> vec<T, sizeof...(U) + 1>;`

* Create another `vec` with specifying `T` and `U` with same vector elements.

* Use `for` loop to check that elements inside vectors are the same.
