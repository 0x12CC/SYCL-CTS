:sectnums:
:xrefstyle: short

= Test plan for atomic_ref

This is a test plan for the APIs described in SYCL 2020 section 4.15.3. Atomic references

== Testing scope

The test plan covers non-atomic behavior, the latter will be covered in a separate test plan

=== Device coverage

All of the tests described below are performed

* on the default device that is selected on the CTS command line
* on the host side

== Type coverage

All of the tests described below are performed using each of the
following types as the `ReferencedType`.

In Regular mode:

* `int`
* `float`

In full conformance mode:

* `int`
* `unsigned int`
* `long`
* `unsigned long`
* `float`

In addition, if the device has `aspect::atomic64`, the following types are tested:

* `long long`
* `unsigned long long`
* `double`

Note: for the following types should use an `epsilon` parameter for comparison operators to take into account possible different rounding mode:

* `float`
* `double`

== Tests

Note: all tests run with different values of `DefaultOrder` and `DefaultScope` template parameters, for usupported values tests are skiped. To check if the special values of `DefaultOrder` parameters are supported should use `info::device::atomic_memory_order_capabilities`, `memory_order::relaxed` should be supported on all devices. To check if the special values for `DefaultScope` parameter are supported should use `info::device::atomic_memory_scope_capabilities`.

=== SYCL2020 interface

==== Memory order traits

For the following `ReadModifyWriteOrder` template parameter values:

* `memory_order::relaxed`

Check the following:
`memory_order_traits<memory_order::relaxed>::read_order` is equal to `memory_order::relaxed`,
`memory_order_traits<memory_order::relaxed>::write_order` is equal to `memory_order::relaxed`

* `memory_order::acq_rel`

Check the following:
`memory_order_traits<memory_order::acq_rel>::read_order` is equal to `memory_order::acquire`,
`memory_order_traits<memory_order::acq_rel>::write_order` is equal to `memory_order::release`

* `memory_order::seq_cst`

Check the following:
`memory_order_traits<memory_order::seq_cst>::read_order` is equal to `memory_order::seq_cst`,
`memory_order_traits<memory_order::seq_cst>::write_order` is equal to `memory_order::seq_cst`

Check that `read_order` and `write_oder` members of `memory_order_traits<ReadModifyWriteOrder>` are const.

==== Members

Create an `atomic_ref` object in host and device code with the following `DefaultOrder` template parameter values:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

Check the following:
`default_read_order` member is equal to `memory_order_traits<DefaultOrder>::read_order`,
`default_write_order` member is equal to `memory_order_traits<DefaultOrder>::write_order` and
`default_read_modify_write_order` member is equal to `DefaultOrder`

Check that:

* `default_read_order`, `default_write_order` and `default_read_modify_write_order` members are const
* `required_alignment` memeber is const and is equal to or grater than `alignof(T)` where `T` is `ReferencedType`
* `is_always_lock_free` member is const and is equal to `true` of `false`
* `default_scope` member is const and is equal to `DefaultScope` template parameter was used when object was created

Check whether type `atomic_ref<T, DefaultOrder, DefaultScope, Space>::value_type` is same as `T` template parameter.

==== Common constructors

Create an `atomic_ref` object using `atomic_ref(T&)` and an other object using copy constructor in host and device code using the following values as `DefaultOrder` template parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

The following values as `DefaultScope` template parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

And the following values as `Space` template parameter:

* `access::address_space::global_space`
* `access::address_space::local_space`
* `access::address_space::generic_space`

After calling constructors check for:

* `atomic_ref(T&)`

If the members of newly created object match with defult values and the stored value match with the value passed as `T&` using
`T load(
    memory_order order = default_read_order
    memory_scope scope = default_scope) const`.
Check returned value type of `load` member function.

* `atomic_ref(const atomic_ref&) noexcept`

If the members of the newly created object match that of `const atomic_ref&` and the referenced value is valid using
`T load(
    memory_order order = default_read_order
    memory_scope scope = default_scope) const`.


==== Member functions

`bool is_lock_free()`

Check if the function exists and returns `true` or `false`
Check returned value type.

`void store(T operand,
    memory_order order = default_write_order,
    memory_scope scope = default_scope)`

For the following values as `order` parameter:

* `memory_order::relaxed`
* `memory_order::release`
* `memory_order::seq_cst`

For the following values as `scope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

Check if the function stores `operand` to the object referenced by this `atomic_ref`.

`T operator=(T desired) const noexcept`

Same as `store(desired)`: Check if the function stores `desired` to the object referenced by this `atomic_ref`.
Check if returned value is `desired` and check returned value type.

`operator T() const`

Check if the function loads the value of the object referenced by this `atomic_ref`.

`T exchange(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

For the following values as `order` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

For the following values as `scope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

Check if replaces the value of the object referenced by this `atomic_ref` with value `operand` and returns the original value of the referenced object. Check returned value type.

`bool compare_exchange_weak(T &expected, T desired,
    memory_order success,
    memory_order failure,
    memory_scope scope = default_scope) const`

For the following values as `success` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

For the following values as `failure` parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`

For the following values as `scope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

For equal values: it attempts to replaces the value of the referenced object with the value of `desired`. This may not be checked since it is non-deterministic.

For unequal values: check if it assigns the original value of the referenced object to `expected`.

Also check if it returns `true` when the comparison operation and replacement operation were successful.

Check returned value type.

`bool compare_exchange_weak(T &expected, T desired,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Same as above: Equivalent to `compare_exchange_weak(expected, desired, order, order, scope)` using following values as `order` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

`bool compare_exchange_strong(T &expected, T desired,
    memory_order success,
    memory_order failure,
    memory_scope scope = default_scope) const`

For the following values as `success` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

For the following values as `failure` parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`

For the following values as `scope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

For equal values: check if it replaces the value of the referenced object with the value of `desired`.

For unequal values: check if it assigns the original value of the referenced object to `expected`.

Also check if it returns `true` when the comparison operation was successful.

Check returned value type.

`bool compare_exchange_strong(T &expected, T desired,
    memory_order order =
    default_read_modify_write_order) const`

Same as above: Equivalent to `compare_exchange_strong(expected, desired, order, order, scope)` using following values as `order` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

==== Additional member functions available on an object of type `atomic_ref<T>` for integral `T`

For the following values as `order` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

For the following values as `scope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

`T fetch_add(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it adds `operand` to the value of the object referenced by this `atomic_ref` and assigns the result to the value of the referenced object. 
Check if it returns the original value of the referenced object. Check returned value type.

`T operator+=(T operand) const`

Same as above: Equivalent to `fetch_add(operand) + operand`.

`T operator++(int) const`

Same as `fetch_add`: Equivalent to `fetch_add(1)`.

`T operator++() const`

Same as `fetch_add`: Equivalent to `fetch_add(1) + 1`.

`T fetch_sub(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it subtracts `operand` from the value of the object referenced by this `atomic_ref` and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object. Check returned value type.

`T operator-=(T operand) const`

Same as above: Equivalent to `fetch_sub(operand) - operand`.

`T operator--(int) const`

Same as `fetch_sub`: Equivalent to `fetch_sub(1)`.

`T operator--() const`

Same as `fetch_add`: Equivalent to fetch_sub(1) - 1.

`T fetch_and(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it performs a bitwise AND between `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object. Check if it returns the original value of the referenced object. Check returned value type.

`T operator&=(T operand) const`

Same as above: Equivalent to `fetch_and(operand) & operand`.

`T fetch_or(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it performs a bitwise OR between `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object. Check if it returns the original value of the referenced object. Check returned value type.

`T operator|=(T operand) const`

Same as above: Equivalent to `fetch_or(operand) | operand`.

`T fetch_xor(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it performs a bitwise XOR between `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object. Check if it returns the original value of the referenced object. Check returned value type.

`T operator^=(T operand) const`

Same as above: Equivalent to `fetch_xor(operand) ^ operand`.

`T fetch_min(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the minimum of `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object. Check returned value type.

`T fetch_max(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the maximum of `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object. Check returned value type.

==== Additional member functions available on an object of type `atomic_ref<T>` for floating-point `T`

For the following values as `order` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

For the following values as `scope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

`T fetch_add(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it adds `operand` to the value of the object referenced by this `atomic_ref` and assigns the result to the value of the referenced object. Check that new value of the referenced object is equal to `(previous value + operand) +- epsilon`. Check if it returns the original value of the referenced object. Check returned value type.

`T operator+=(T operand) const`

Same as above: Equivalent to `fetch_add(operand) + operand`.

`T fetch_sub(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it subtracts `operand` from the value of the object referenced by this `atomic_ref` and assigns the result to the value of the referenced object. Check that new value of the referenced object is equal to `(previous value - operand) +- epsilon`. Check if it returns the original value of the referenced object. Check returned value type.

`T operator-=(T operand) const`

Same as above: Equivalent to `fetch_sub(operand) - operand`.

`T fetch_min(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the minimum of `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object. Check that new value of the referenced object is equal to `(minimum value) +- epsilon`. Check if it returns the original value of the referenced object. Check returned value type.

`T fetch_max(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the maximum of `operand` and the value of the object referenced by this `atomic_ref`, and assigns the result to the value of the referenced object. Check that new value of the referenced object is equal to `(maximum value) +- epsilon`. Check if it returns the original value of the referenced object. Check returned value type.