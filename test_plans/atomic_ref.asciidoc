:sectnums:
:xrefstyle: short

= Test plan for atomic_ref

This is a test plan for the APIs described in SYCL 2020 section 4.15.3. Atomic references

== Testing scope

The test plan covers non-atomic behavior, the latter will be covered in a separate test plan

=== Device coverage

All of the tests described below are performed

* on the default device that is selected on the CTS command line
* on the host side

== Type coverage

All of the tests described below are performed using each of the
following types as the `ReferencedType`.

In Regular mode:

* `int`
* `float`

In full conformance mode:

* `int`
* `unsigned int`
* `long`
* `unsigned long`
* `float`

In addition, if the device has `aspect::atomic64`, the following types are tested:

* `long long`
* `unsigned long long`
* `double`

Note: for the following types should use an `epsilon` parameter for comparison operators to take into account possible different rounding mode:

* `float`
* `double`

== Tests

Note: all test run with different values of `DefaultOrder` and `DefaultScope` template parameters, for usupported values tests are skiped. To check if the special values of `DefaultOrder` parameters are supported should use `info::device::atomic_memory_order_capabilities`, `memory_order::relaxed` should be supported on all devices. To check if the special values for `DefaultScope` parameter are supported should use `info::device::atomic_memory_scope_capabilities`.

=== SYCL2020 interface

==== Members

Create an atomic_ref object in host and device code with the following `DefaultOrder` parameter values:

* `memory_order::relaxed`

Check the following:
`default_read_order` member is `memory_order::relaxed` and
`default_write_order` member is `memory_order::relaxed` and
`default_read_modify_write_order` member is `memory_order::relaxed`


* `memory_order::acq_rel`

Check the following:
`default_read_order` member is `memory_order::acquire` and
`default_write_order` member is `memory_order::release` and
`default_read_modify_write_order` member is `memory_order::acq_rel`

* `memory_order::seq_cst`

Check the following:
`default_read_order` member is `memory_order::seq_cst` and
`default_write_order` member is `memory_order::seq_cst` and
`default_read_modify_write_order` member is `memory_order::seq_cst`

Check whether the following members exist:

* `static constexpr size_t required_alignment`
* `static constexpr bool is_always_lock_free`
* `static constexpr memory_scope default_scope`

Check that:

* `required_alignment` is equal to or grater than alignof(T), where T is `ReferencedType`
* `default_scope` is equal to `DefaultScope` template parameter using when object was created


==== Common constructors

Create an atomic_ref object using `atomic_ref(T&)` and an other object using copy constructor in host and device code using the following values as `DefaultOrder` parameter:

* `memory_order::relaxed`
* `memory_order::acq_rel`
* `memory_order::seq_cst`

The following values as `DefaultScope` parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

And the following values as `Space` parameter:

* `access::address_space::global_space`
* `access::address_space::local_space`
* `access::address_space::generic_space`

After calling constructors check for:

* `atomic_ref(T&)`

If the members of newly created object match with defult values and the stored value match with the value passed as `T&` using
`T load(
    memory_order order = default_read_order
    memory_scope scope = default_scope) const`.
Check returned value type of `load` function.

* `atomic_ref(const atomic_ref&) noexcept`

If the members of the newly created object match that of `const atomic_ref&` and the referenced value is valid using
`T load(
    memory_order order = default_read_order
    memory_scope scope = default_scope) const`.


==== Member functions

`bool is_lock_free()`

Check if the function exists and returns `true` or `false`

`void store(T operand,
    memory_order order = default_write_order,
    memory_scope scope = default_scope)`

For the following values as order parameter:

* `memory_order::relaxed`
* `memory_order::release`
* `memory_order::seq_cst`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

Check if the function stores `operand` to the object referenced by this atomic_ref.

`T operator=(T desired) const noexcept`

Same as `store(desired)`: Check if the function stores `operand` to the object referenced by this atomic_ref.

`operator T() const`

For the following values as order parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

Check if the function loads the value of `operand` referenced by this atomic_ref.

`T exchange(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

For the following values as order parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

Check if replaces the value of the object referenced by this atomic_ref with value operand and returns the original value of the referenced object.

`bool compare_exchange_weak(T &expected, T desired,
    memory_order success,
    memory_order failure,
    memory_scope scope = default_scope) const`

For the following values as success and failure parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

For equal values: it attempts to replaces the value of the referenced object with the value of `desired`. This may not be checked since it is non-deterministic.

For unequal values: check if it assigns the original value of the referenced object to `expected`.

Also check if it returns `true` when the comparison operation and replacement operation were successful.

`bool compare_exchange_weak(T &expected, T desired,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Same as above: Equivalent to `compare_exchange_weak(expected, desired, order, order, scope)`.

`bool compare_exchange_strong(T &expected, T desired,
    memory_order success,
    memory_order failure,
    memory_scope scope = default_scope) const`

For the following values as success and failure parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

For equal values: check if it replaces the value of the referenced object with the value of `desired`.

For unequal values: check if it assigns the original value of the referenced object to `expected`.

Also check if it returns `true` when the comparison operation was successful.

`bool compare_exchange_strong(T &expected, T desired,
    memory_order order =
    default_read_modify_write_order) const`

Same as above: Equivalent to `compare_exchange_strong(expected, desired, order, order, scope)`.

==== Additional member functions available on an object of type `atomic_ref<T>` for integral `T`

For the following values as order parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`
* `memory_order::release`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

`T fetch_add(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it adds operand to the value of the object referenced by this atomic_ref and assigns the result to the value of the referenced object. 
Check if it returns the original value of the referenced object. 

`T operator+=(T operand) const`

Same as above: Equivalent to `fetch_add(operand) + operand`.

`T operator++(int) const`

Same as `fetch_add`: Equivalent to `fetch_add(1)`.

`T operator++() const`

Same as `fetch_add`: Equivalent to `fetch_add(1) + 1`.

`T fetch_sub(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it subtracts operand from the value of the object referenced by this atomic_ref and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.

`T operator-=(T operand) const`

Same as above: Equivalent to `fetch_sub(operand) - operand`.

`T operator--(int) const`

Same as `fetch_sub`: Equivalent to `fetch_sub(1)`.

`T operator--() const`

Same as `fetch_add`: Equivalent to fetch_sub(1) - 1.

`T fetch_and(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it performs a bitwise AND between operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.

`T operator&=(T operand) const`

Same as above: Equivalent to `fetch_and(operand) & operand`.

`T fetch_or(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it performs a bitwise OR between operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.

`T operator|=(T operand) const`

Same as above: Equivalent to `fetch_or(operand) | operand`.

`T fetch_xor(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it performs a bitwise XOR between operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.

`T operator^=(T operand) const`

Same as above: Equivalent to `fetch_xor(operand) ^ operand`.

`T fetch_min(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the minimum of operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object. 

`T fetch_max(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the maximum of operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object. 

==== Additional member functions available on an object of type `atomic_ref<T>` for floating-point `T`

For the following values as order parameter:

* `memory_order::relaxed`
* `memory_order::acquire`
* `memory_order::seq_cst`
* `memory_order::release`

For the following values as scope parameter:

* `memory_scope::work_item`
* `memory_scope::sub_group`
* `memory_scope::work_group`
* `memory_scope::device`
* `memory_scope::system`

`T fetch_add(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it adds operand to the value of the object referenced by this atomic_ref and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.

`T operator+=(T operand) const`

Same as above: Equivalent to `fetch_add(operand) + operand`.

`T fetch_sub(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it subtracts operand from the value of the object referenced by this atomic_ref and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.

`T operator-=(T operand) const`

Same as above: Equivalent to `fetch_sub(operand) - operand`.

`T fetch_min(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the minimum of operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object. 
Check if it returns the original value of the referenced object.

`T fetch_max(T operand,
    memory_order order = default_read_modify_write_order,
    memory_scope scope = default_scope) const`

Check if it computes the maximum of operand and the value of the object referenced by this atomic_ref, and assigns the result to the value of the referenced object.
Check if it returns the original value of the referenced object.