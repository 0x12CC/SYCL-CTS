:sectnums:
:xrefstyle: short

= Test plan for bfloat16

This is a test plan for the APIs described in
https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_oneapi_bfloat16.asciidoc[sycl_ext_oneapi_bfloat16]

== Testing scope

=== Device coverage

All of the tests described below are performed only on the default device that
is selected on the CTS command line.

=== Type coverage

All of the tests described below are performed using each of the following `typename T`:

* `char`
* `short`
* `int`
* `long long`
* `std::size_t`
* `bool`
* `float`

In addition, if the device has aspect `aspect::fp64`:

* `double`

In addition, if the device has `aspect::fp16`:

* `sycl::half`

Note that `T` must be convertible to `float`

== Tests

=== Constructors

`bfloat16()` +
`bfloat16(const bfloat16 &)`

Check that:

* `std::is_default_constructible_v<bfloat16> == true`.
* `std::is_copy_constructible_v<bfloat16> == true`.

`bfloat16(const float &a)` +
`bfloat16(const sycl::half &a)`

Since `bfloat16` has 7 bits significand, epsilon value for this type is 2^-7, or 0.0078125. Therefore, objects created using these constructors must be in the range `(a - 0.0078125, a + 0.0078125)`. Create `bfloat16` object named `bf` and verify:

* `sizeof(bf) == 2`
* `(bf > a - epsilon) && (bf < a + epsilon)`

=== Conversion

Check that:

* `std::is_convertible_v<bfloat16, float> == true`
* `std::is_convertible_v<bfloat16, sycl::half> == true`
* `std::is_convertible_v<bfloat16, bool> == true`
* `std::is_convertible_v<float, bfloat16> == true`
* `std::is_convertible_v<sycl::half, bfloat16> == true`

=== Operators

`operator-(bfloat16 &bf)`

Check that it constructs new instance of `bfloat16` class with negated value.
Create `neg_bf` using this operator and verify:

* `neg_bf == -bf`
* `bf == -neg_bf`

(Prefix) +
`bfloat16 &operator++(bfloat16 &bf)` +
`bfloat16 &operator--(bfloat16 &bf)`

* Check if it adds/substracts 1 to the value of the object referenced by this `bf`.
* Check that new value of the referenced object is equal to `(previous value +/- 1)`.
* Check if it returns the copy of `bf`.
* Check returned value type.

(Postfix) +
`bfloat16 operator++(bfloat16 &bf, int)` +
`bfloat16 operator--(bfloat16 &bf, int)`

Same as above, but check thar it returns value of `bf` before assignment instead of copy.

OP is `+=`, `-=`, `*=`, `/=` +
`bfloat16 &operatorOP(bfloat16 &lhs, const bfloat16 &rhs)`

* Check results of arithmetic operations returned to initial `bfloat16` object.
* Check returned value type.

OP is `+`, `-`, `*`, `/` +
`bfloat16 operatorOP(const bfloat16 &lhs, const bfloat16 &rhs)`

* Check results of arithmetic operations.
* Check returned value type.

OP is `==`, `!=`, `<`, `>`, `<=`, `>=` +
`bool operatorOP(const bfloat16 &lhs, const bfloat16 &rhs)`

* Check results of equality and inequality between two `bfloat16` objects.
* Check returned type is `bool`.

OP is `==`, `!=`, `<`, `>`, `<=`, `>=` +
`template <typename T>` +
`bool operatorOP(const bfloat16 &lhs, const T &rhs)` +
`template <typename T>` +
`bool operatorOP(const T &lhs, const bfloat16 &rhs)`

* Check results of equality and inequality between `bfloat16` and `T` objects.
* Check returned type is `bool`.
