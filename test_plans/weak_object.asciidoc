:sectnums:
:xrefstyle: short

= Test plan for weak object

This is a test plan for the APIs described in
https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_oneapi_weak_object.asciidoc[sycl_ext_oneapi_weak_object]

== Testing scope

=== Device coverage

All of the tests described below are performed only on the default device that
is selected on the CTS command line.

=== Feature test macro

All of the tests should use `#ifdef SYCL_EXT_ONEAPI_WEAK_OBJECT` so they can be skipped
if feature is not supported.

=== Type coverage
All of the tests for `weak_object` described below are performed using each of the following `typename SyclObject`:

* `buffer<int>`         +
* `accessor<int>`       +
* `host_accessor<int>`  +
* `local_accessor<int>` +
* `context`             +
* `event`               +
* `queue`               +
* `stream`

== Objects creation

All of the tests for `weak_object` described below using SYCL objects and empty or non-empty objects:

* SYCL objects created by using default constructors or passing sample data:

** `buffer<int>`
+
----
buffer<int> b{{1}}
----

** `accessor<int>`
+
----
buffer<int> b{{1}};
accessor a{b}
----

** `host_accessor<int>`
+
----
buffer<int> b{{1}};
host_accessor a{b}
----

** `local_accessor<int>`
+
----
queue q;
q.submit([&](handler &cgh) {
    local_accessor<int> a{{1}, cgh};
})
----

** `context`
+
----
context c;
----

** `event`
+
----
event e;
----

** `queue`
+
----
queue q;
----

** `stream`
+
----
queue q;
q.submit([&](handler &cgh) {
  stream s{1, 1, cgh};
})
----

* Empty `weak_object` created by using `constexpr weak_object()` constructor

* Non-empty `weak_object` created by using `weak_object(const SyclObject &SYCLObj)` constructor

== Tests

=== API tests

General checks for all of created `weak_object`. First initialize `ret` using `try_lock()`, then:

* If the weak_object was constructed with an underlying SYCL object `SyclObj`, check that:
** `ret.value() == SYCLObj`
** `std::is_same_v<decltype(ret.value(), SyclObject)>`
** Call `lock` and verify that the value it returns compares equal to `SyclObj`.
** Call `reset`, and then verify that `expired()` returns `false`.

* If the weak_object was constructed with no underlying SYCL object, check that:
** `ret.has_value() == false`
** Call `lock` and verify that it throws `errc::invalid` exception

=== Constructors

Create instances of `weak_object` using: +
`constexpr weak_object()` +
`weak_object(const SyclObject &SYCLObj)` +
`weak_object(const weak_object &Other)` +
`weak_object(weak_object &&Other)` +

Perform tests described above in the "API" section.

=== Copy and move assignment operators

Use the existing instances of `weak_object` from the previous section, copy or move them into another objects using following operators: +
`weak_object &operator=(const SyclObject &SYCLObj)` +
`weak_object &operator=(const weak_object &Other)` +
`weak_object &operator=(weak_object &&Other)`

Perform tests described above in the "API" section.

=== swap member function

Using the objects created in the "Constructors" section, do the following:

* Create an empty `weak_object` of the same type by using the default constructor.

* Call `swap` on that object, passing the object from the "Constructors" section.

* Perform tests described above in the "API" section.

=== Expiring

* Create local scope with `SyclObject` and assign it to `weak_object` that is outside this scope. Check that `expired()` returns `false` now and `true` after `SyclObject` is destroyed outside the scope

* Check that `expire()` returns `bool` type using `std::is_same_v`

=== owner_before and owner_less

Create two pairs of `weak_object` objects, the first of which encapsulate the same SYCLObj, and the second are empty

* Check that `owner_before(const weak_object &Other)` returns `false` with passing second `weak_object` for both pairs

* CHeck that `owner_before(const SyclObject &Other)`returns `false` with passing referred SyclObj for both pairs

* Check that `owner_less{}(const T &lhs, const T &rhs)` +
`owner_less{}(const weak_object<T> &lhs, const weak_object<T> &rhs)` +
`owner_less{}(const T &lhs, const weak_object<T> &rhs)` +
`owner_less{}(const weak_object<T> &lhs, const T &rhs)` +
return `false` if `lhs` and `rhs` `weak_object` or `SYCLObj` they refers are both the same or empty

=== ext_oneapi_owner_before
Create `SyclObject` and `weak_object` which encapsulate it.

* Check that `SyclObject::ext_oneapi_owner_before` returns `false` with passing created `weak_object`
