:sectnums:
:xrefstyle: short

= Test plan for sub-group class

This is a test plan for the sub-group class as described in Section 4.9.1.8. of the SYCL 2020 specification.

Estimated development time is three days.

== Testing scope

=== Backend coverage

All the tests described below are not backend-specific and are performed for any SYCL backend.

=== Device coverage

All tests construct a test device for which conformance is assessed. All the tests described below are performed once for that test device.

== Tests
Two tests are defined, depending on whether the test has knowledge of the actual sub-group size. In some cases, this may not be enforceable and be decided by the compiler.

=== With unknown sub-group size
This test is always executed. A kernel is defined that calls all functions below, checks their return type and records the returned value in a list of a size equal to the number of work-items times the number of functions. This list is initialized such that it can be asserted that each element is written to.

The kernel is called with `parallel_for(nd_range<3>(global_range, local_range), [](nd_item<1> item){})`, where `local_range` is `1023` in every dimension to likely contain multiple sub-groups and likely to contain an incomplete sub-group. `local_range` is decreased depending on `info::device::max_work_group_size` and `info::device::max_work_item_sizes`. `global_range` is `range<3>(2, 2, 2) * local_range`. The work-items index the list of results with `item.get_global_linear_id()`. Let `sub_group` be `item.get_sub_group()`:

- `sub_group.get_group_id()`
- `sub_group.get_group_linear_id()`
- `sub_group.get_local_id()`
- `sub_group.get_local_linear_id()`
- `sub_group.get_local_range()`
- `sub_group.get_local_linear_range()`
- `sub_group.get_group_range()`
- `sub_group.get_group_linear_range()`
- `sub_group.get_max_local_range()`
- `sub_group.leader()`
- `item.get_group_linear_id()`

The following tests are performed for each work-item:

- `sub_group.get_group_id()[0]` is equal to `sub_group.get_group_linear_id()` and within `sub_group.get_group_range()[0]`.
- `sub_group.get_local_id()[0]` is equal to `sub_group.get_local_linear_id()` and within `sub_group.get_local_range()[0]`.
- `sub_group.get_local_range()[0]` is equal to `sub_group.get_local_linear_range()` and is smaller or equal to `sub_group.get_max_local_range()[0]`.
- `sub_group.get_group_range()[0]` is equal to `sub_group.get_group_linear_range()`.
- Calculate a global index for each work-item using `sub_group.get_group_id()`, `sub_group.get_local_id()`, and `item.get_group_linear_id()`. Each global index should be unique.
- `sub_group.leader()` is true if and only if `sub_group.get_local_id()` is zero.

Furthermore, the following tests are performed:

- `sub_group.get_max_local_range()[0]` is the same for every work-item, and the value matches one of the values returned by querying `sycl::info::device::sub_group_size`.
- Every value of the list of results is written to, indicating that each work-item has called the specified functions.

=== With known sub-group size
This test is only executed if the sub-group size can be enforced, see below. A kernel is defined that calls all functions below, checks their return type and records the returned value in a list of a size equal to the number of work-items times the number of functions. The kernel is called with `parallel_for(nd_range<1>(range<1>(work_group_size), range<1>(work_group_size)), [](nd_item<1> item){})`, let `sub_group` be `item.get_sub_group()`:

- `sub_group.get_group_id()` and `sub_group.get_group_linear_id()`
+
Returns the id of the sub-group within the work-group.
- `sub_group.get_local_id()` and `sub_group.get_local_linear_id()`
+
Returns the id work-item's position in the sub-group.
- `sub_group.get_local_range()` and `sub_group.get_local_linear_range()`
+
Returns the size of the subgroup. Should be `sub_group_size` (see below) for all but the last sub-group, in which case it should be `sub_group_size - 1`.
- `sub_group.get_group_range()` and `sub_group.get_group_linear_range()`
+
Returns the number of sub-groups within the work-group. Should be `3` (see below).
- `sub_group.get_max_local_range()`
+
Returns the maximum number of items in the sub-group. Should be `sub_group_size` (see below).
- `sub_group.leader()`
+
Returns `true` only for the work-item within each sub-group with a local id of zero.

The kernel is compiled multiple times, with the attribute `reqd_sub_group_size(dim)` for `dim` in range `1, ..., 64`. At runtime, `info::device::sub_group_sizes` is queried for the device, to obtain the supported sub-group sizes. The largest sub-group size that is smaller or equal to 64 is chosen to be `sub_group_size`. The kernel is executed with a `work_group_size` equal to `3 * sub_group_size - 1`. If no such sub-group size exists, the test is not executed.
