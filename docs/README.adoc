= SYCL CTS Developer Documentation
:toc:
:tip-caption: üí°
:important-caption: ‚ùó
:warning-caption: ‚ö†Ô∏è

This document is intended as a comprehensive reference for developers wanting to contribute to the SYCL CTS.

== General

- Overview of the SYCL Conformance Test Suite

== Procedures

- Test Plans
- Pull Requests
- Continuous Integration (CI)

== Coding Guidelines

** TODO **

== Writing Tests

This section contains guidelines on how to write test cases for the SYCL CTS.
We recommend that you try and stick to these guidelines, however, they are not to be considered hard and fast rules, and best practices are still being developed.

=== Test Categories

Test cases in the SYCL CTS are grouped into _categories_.
Each folder in the link:../tests[`tests`] directory corresponds to one such category.
Each category is comprised of one or more translation units and is compiled into a single test executable, named `test_<category>`.

TIP: Before adding a test case, consider whether there already exists a category it would fit into, or whether a new category is required.

TIP: The CTS supports disabling the compilation of entire categories for certain SYCL implementations.
See link:procedures.adoc[Procedures] for more information.

=== Setting up a Simple Category & Test Case

To create a new test category create the following files inside the link:../tests[`tests`] directory:

```
tests
‚îî‚îÄ‚îÄ simple
   ‚îú‚îÄ‚îÄ CMakeLists.txt
   ‚îî‚îÄ‚îÄ simple.cpp
```

In `tests/simple/CMakeLists.txt` add the following boilerplate:

[source,cmake]
----
file(GLOB test_cases_list *.cpp)
add_cts_test(${test_cases_list})
----

Then in `tests/simple/simple.cpp` add the following:

[source,c++]
----
#include "../common/common.h"

TEST_CASE("a simple test case", "[simple]") {
    sycl::buffer<int> buf(1);
    sycl::queue queue = sycl_cts::util::get_cts_object::queue();
    queue.submit([&](sycl::handler& cgh) {
        sycl::accessor w{buf, cgh, sycl::write_only};
        cgh.single_task<class simple_kernel>([=] {
            w[0] = 42;
        });
    });

    sycl::host_accessor r{buf, sycl::read_only};
    CHECK(r[0] == 42);
}
----

This adds a test case with the description `"a simple test case"` and the _tag_ `[simple]`.
Both can later be used to narrow down the set of test cases that will be executed during runtime.

When configuring CMake, the new test category will automatically be detected and a target with the name `test_simple` is added.
You can run the test case by either executing `./bin/test_simple` directly, or alternatively as part of `./bin/test_all`.

IMPORTANT: For historic reasons, the CTS currently contains many test cases that are written in a different style.
Please see <<New-style vs Legacy Test Cases>> for more information.

=== Important Catch2 Concepts

The SYCL CTS relies on https://github.com/catchorg/Catch2/[Catch2] as its underlying testing framework.
This section will list the most important concepts required to write tests with Catch2.
For a comprehensive overview of all features, please refer to the https://github.com/catchorg/Catch2/tree/devel/docs[Catch2 documentation].
In addition, the CTS provides several custom utilities to extend Catch2's feature set.
See <<Special Macros & Custom Matchers>> for more information.

==== Test Case Macros

Catch2 provides several macros of varying complexity for defining test cases.
While different macros take different parameters, they all require a *description* and optionally a list of *tags* to be specified.


- `TEST_CASE` is the most basic macro, useful for test cases that deal with APIs that are not templated in any way.
- `TEMPLATE_TEST_CASE` can be provided with one or more types that are then available as `TestType` within the test case.
The test case is then instantiated separately for each type.
- `TEMPLATE_TEST_CASE_SIG` can be used to make one or more template parameters (including non-type template parameters) available under a custom name.

TIP: Use `TEMPLATE_TEST_CASE_SIG("my test", "[my-tag]", ((int D), D), 1, 2, 3)` to test APIs that support multiple dimensions.
The test case will be executed three times, with `D` having a value of `1`, `2` and `3`.

==== Assertion Macros

* `CHECK(condition)` asserts that the provided condition is true. If it is false, the assertion failure will be reported and the test case continues execution.
* `REQUIRE(condition)` like `CHECK`, but will abort the current test case upon failure.

TIP: Use `CHECK` by default, only resort to `REQUIRE` when further execution of a test case would result in a crash (for example `REQUIRE(arr.size() >= 2); if(arr[1] == 123) { /* ... */ }`).

==== Providing Context

While Catch2 already provides great error reporting out of the box, it can sometimes be helpful to provide additional context alongside a failing assertion.

* `CAPTURE(...)` can be used to print the name and value of arbitrary values alongside a failing assertion.
* `INFO(message)` allows to provide additional information in the form of natural language descriptions.
`iostream`-style formatting is supported.

Example usages of both:
[source,c++]
----
TEST_CASE("my test case") {
    const int x = 3;
    const int y = 4;
    const int z = x * y;
    // Shorthand
    CAPTURE(x, y);
    // More verbose
    INFO("checking that x (" << x << ") times y (" << y << ") equals 20");
    CHECK(z == 20);
}
----

==== Sections

**TODO**

=== Special Macros & Custom Matchers

The SYCL CTS extends Catch2's functionality with several custom macros and matchers.

==== Compile-Time Disabled Test Cases

* `DISABLED_FOR_TEST_CASE`
* `DISABLED_FOR_TEMPLATE_TEST_CASE_SIG`

=== Best Practices

Here is a list of best practices for writing test cases.
These are not set in stone and are likely to evolve over time.

* Always write tests using Catch2 macros, avoid <<new-style-vs-legacy-test-cases,legacy test cases>>.
* Avoid old-style `if(!condition) FAIL("reason");` pattern.
  Use `CHECK(condition)` instead.
* Keep test cases small and focused to a single concept / behavior.
  Even a single function could be tested with several test cases.
* Use natural language descriptions for test cases:
    ** Avoid: `"host_accessor range mismatch exception"`.
    ** Prefer: `"host_accessors throws if accessed range exceeds buffer dimensions"`.
* Tag test cases according to the feature being tested:
    ** Use `[some_type]` for types that exist in the SYCL specification (example: `[host_accessor]`).
    ** Use `[some-concept]` for concepts without a clearly associated type (example: `[backend-interop]`).
* Group test cases into files at your own discretion.
  It is certainly possible to have all test cases for a given API within the same file.
  However, for larger features distributing test cases across multiple files may be preferable.
* Try to order test cases in a file in the same order as their associated API specification (if possible).

=== New-style vs Legacy Test Cases

When browsing the CTS, you will likely encounter two different kinds of test cases: **New-style test cases** and **legacy test cases**.
New-style test cases are written using free-standing https://github.com/catchorg/Catch2/[Catch2] macros such as `TEST_CASE` and will look something like this:

[source,c++]
----
TEST_CASE("SYCL feature XY works as expected", "[feature-xy]") {
    // ...
    CHECK(works_as_expected);
}
----

Importantly, multiple of these test cases will typically be grouped into a single file.

Legacy test cases on the other hand use a class-based approach, where a test case is implemented by extending the `sycl_test::util::test_base` class.
Testing logic is then implemented in the `run` member function:

[source,c++]
----
#define TEST_NAME feature_xy

namespace TEST_NAMESPACE {
using namespace sycl_cts;

class TEST_NAME : public util::test_base {
public:
  void get_info(test_base::info &out) const override { /* ... */ }

  void run(util::logger &log) override {
      // ...
      if(!works_as_expected) {
          FAIL("feature XY does not work as expected");
      }
  }
};

util::test_proxy<TEST_NAME> proxy;
}
----

While legacy test cases are still mapped to Catch2 under the hood, they require a lot of boilerplate code and therefore testing logic for distinct aspects of a feature are often grouped into a single test case, making them harder to comprehend and debug.
Although technically not required, usually only one class extending `test_base` is defined per file.

IMPORTANT: Always write new-style test cases.
